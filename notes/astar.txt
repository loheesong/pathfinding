AStar(Maze maze, Node start, Node end) {
    priority_queue queue();
    // Init all distances with infinity
    for (auto&& node : maze.nodes) {
      node.distance = Infinity;
      node.rootDistance = Infinity;
      // Note: we may reinforce the manhattan heuristic
      node.manhattanD = 2 * 
        (Math.abs(end.x - node.x) + Math.abs(end.y - node.y));
    }
    // Distance to the root itself is zero
    start.rootDistance = 0;
    // Init queue with the root node
    queue.add(start, 0);
    // Iterate over the priority queue until it is empty.
    while (!queue.isEmpty()) {
      curNode = queue.dequeue();  // Fetch next closest node
      curNode.discovered = true;  // Mark as discovered
      // Iterate over unvisited neighbors
      for (auto&& neighbor : curNode.GetUnvisitedNeighbors())
      {
        // Update root minimal distance 
        neighbor.rDistance =
          Math.min(neighbor.rootDistance, curNode.rootDistance + 1);
        const minDistance =
          Math.min(neighbor.distance, 
            neighbor.rootDistance + neighbor.manhattanD);
        
        if (minDistance !== neighbor.distance) {
          neighbor.distance = minDistance;  
          neighbor.parent = curNode;        
          // Change queue priority of the neighbor 
          if (queue.has(neighbor)) 
            queue.setPriority(neighbor, minDistance);
        }
        // Add neighbor to the queue for further visiting.
        if (!queue.has(neighbor)) 
          queue.add(neighbor, neighbor.distance);
      }
    }
  // Done ! At this point we just have to walk back from the end usin